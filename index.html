<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Genesys Cloud vCard Sender</title>
  <script type="text/javascript" src="https://sdk-cdn.mypurecloud.com/javascript/181.0.0/purecloud-platform-client-v2.min.js"></script>
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .status-section {
      margin-bottom: 20px;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
    }
    
    .button-section {
      margin-top: 20px;
    }
    
    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
    }
    
    button:hover {
      background-color: #0056b3;
    }
    
    button:disabled {
      background-color: #6c757d;
      cursor: not-allowed;
    }
    
    .log-section {
      margin-top: 20px;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      background-color: white;
      border-left: 3px solid #007bff;
      font-family: monospace;
      font-size: 12px;
    }
    
    .error {
      border-left-color: #dc3545;
      color: #dc3545;
    }
    
    .success {
      border-left-color: #28a745;
      color: #28a745;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Genesys Cloud vCard Sender</h1>
    
    <div class="status-section">
      <h3>Status Information</h3>
      <div><strong>User:</strong> <span id="userName">Not logged in</span></div>
      <div><strong>Status:</strong> <span id="userStatus">Unknown</span></div>
      <div><strong>Authentication:</strong> <span id="authStatus">Not authenticated</span></div>
    </div>
    
    <div class="status-section">
      <h3>Conversation Information</h3>
      <div id="conversationInfo">No active conversation detected</div>
    </div>
    
    <div class="button-section">
      <button id="sendVCardBtn" onclick="sendVCard()" disabled>Send vCard</button>
      <button id="refreshBtn" onclick="refreshUserInfo()">Refresh User Info</button>
      <button id="authBtn" onclick="authenticateUser()">Re-authenticate</button>
      <button id="checkConversationBtn" onclick="getActiveConversation()">Check Active Conversations</button>
    </div>
    
    <div class="log-section">
      <h3>Debug Log</h3>
      <div id="logContainer"></div>
    </div>
  </div>

  <script>
    // Configuration - Replace with your actual values
    const config = {
      clientId: "2be04b1e-0729-4e4f-ab36-07f28ef606b6", // Your client ID
      region: "usw2.pure.cloud", // Your region
      redirectUri: "https://labpeccloud.github.io/vcard.github.io/index.html" // Your exact GitHub Pages URL
    };

    // Global variables
    let genesysClient;
    let me;
    let conversationApi;
    let usersApi;
    let notificationsApi;
    let contentManagementApi;
    let webSocket;
    
    // Variables to store conversation data from notifications
    let v_toaddress = null;
    let v_conversationId = null;
    let v_workspace_id = null;
    let v_sms_from_address = null;

    // Initialize the application
    async function initialize() {
      log("Starting initialization...");
      
      try {
        // Get Genesys SDK reference
        const genesysSDK = window.require('platformClient');
        genesysClient = genesysSDK.ApiClient.instance;
        
        log("Genesys SDK loaded successfully");
        
        // Initialize API instances
        conversationApi = new genesysSDK.ConversationsApi();
        usersApi = new genesysSDK.UsersApi();
        notificationsApi = new genesysSDK.NotificationsApi();
        contentManagementApi = new genesysSDK.ContentManagementApi();
        
        // Set environment
        genesysClient.setEnvironment(config.region);
        log(`Environment set to: ${config.region}`);
        log(`Current URL: ${window.location.href}`);
        log(`Current hash: ${window.location.hash}`);
        
        // Check if we have a hash (token) or need to authenticate
        if (!window.location.hash) {
          log("No token found in URL hash, starting authentication...");
          await authenticateUser();
        } else {
          log("Token found in URL hash, processing authentication...");
          await processAuthToken();
        }
        
      } catch (error) {
        logError("Initialization failed:", error);
      }
    }

    // Authenticate user using implicit grant
    async function authenticateUser() {
      try {
        log(`Starting OAuth with client ID: ${config.clientId}`);
        log(`Redirect URI: ${config.redirectUri}`);
        
        await genesysClient.loginImplicitGrant(config.clientId, config.redirectUri);
        log("Authentication request sent - redirecting...");
        
      } catch (error) {
        logError("Authentication failed:", error);
        document.getElementById("authStatus").innerText = "Authentication failed";
      }
    }

    // Process the authentication token
    async function processAuthToken() {
      try {
        log("Processing authentication token...");
        
        // Try to use loginImplicitGrant which handles the token processing
        await genesysClient.loginImplicitGrant(config.clientId, config.redirectUri);
        
        // Check if authentication was successful
        if (genesysClient.authData && genesysClient.authData.accessToken) {
          log("Authentication token processed successfully!");
          log(`Token expires in: ${genesysClient.authData.tokenExpiryTimeUtcSeconds}`);
          logSuccess("User authenticated successfully");
          document.getElementById("authStatus").innerText = "Authenticated";
          
          // Process conversation notifications
    function processConversationNotification(data) {
      try {
        log("Processing conversation notification...");
        log(`Topic: ${data.topicName}`);
        log(`Event Body:`, JSON.stringify(data.eventBody, null, 2));
        
        if (data.eventBody && data.eventBody.participants) {
          // Store conversation ID
          if (data.eventBody.id) {
            v_conversationId = data.eventBody.id;
            log(`‚úì Stored conversation ID: ${v_conversationId}`);
          }
          
          // Find customer participant
          const customerParticipant = data.eventBody.participants.find(p => p.purpose === 'customer');
          
          if (customerParticipant) {
            log("‚úì Found customer participant:");
            log(`  - ID: ${customerParticipant.id}`);
            log(`  - Name: ${customerParticipant.name}`);
            log(`  - Purpose: ${customerParticipant.purpose}`);
            
            // 1. Get customer address
            if (customerParticipant.address) {
              v_toaddress = customerParticipant.address;
              log(`‚úì Stored customer address: ${v_toaddress}`);
            } else {
              log("‚ö† No address found in customer participant");
            }
            
            // 3. Get attributes from customer participant
            if (customerParticipant.attributes) {
              log("‚úì Customer attributes found:");
              log(JSON.stringify(customerParticipant.attributes, null, 2));
              
              if (customerParticipant.attributes.workspace_id) {
                v_workspace_id = customerParticipant.attributes.workspace_id;
                log(`‚úì Stored workspace ID: ${v_workspace_id}`);
              } else {
                log("‚ö† No workspace_id found in attributes");
              }
              
              if (customerParticipant.attributes.sms_from_address) {
                v_sms_from_address = customerParticipant.attributes.sms_from_address;
                log(`‚úì Stored SMS from address: ${v_sms_from_address}`);
              } else {
                log("‚ö† No sms_from_address found in attributes");
              }
              
              // Log all available attributes for debugging
              log("All customer attributes:");
              Object.keys(customerParticipant.attributes).forEach(key => {
                log(`  - ${key}: ${customerParticipant.attributes[key]}`);
              });
              
            } else {
              log("‚ö† No attributes object found in customer participant");
            }
            
            // Update UI with conversation info
            updateConversationInfo();
            
            // Log final state
            log("Final conversation variables state:");
            log(`  - v_conversationId: ${v_conversationId}`);
            log(`  - v_toaddress: ${v_toaddress}`);
            log(`  - v_workspace_id: ${v_workspace_id}`);
            log(`  - v_sms_from_address: ${v_sms_from_address}`);
            
            // Check if we have minimum required data
            if (v_conversationId && v_toaddress) {
              logSuccess("Conversation data successfully extracted from notification!");
              document.getElementById("sendVCardBtn").style.backgroundColor = "#28a745"; // Green
            } else {
              logError("Missing required conversation data (conversationId or customer address)");
            }
            
          } else {
            log("‚ö† No customer participant found in conversation");
            log("Available participants:");
            data.eventBody.participants.forEach((p, index) => {
              log(`  ${index + 1}. ID: ${p.id}, Purpose: ${p.purpose}, Name: ${p.name || 'Unknown'}`);
            });
          }
        } else {
          log("‚ö† No participants found in notification event body");
          log("Event body structure:", Object.keys(data.eventBody || {}));
        }
        
      } catch (error) {
        logError("Error processing conversation notification:", error);
      }
    }

    // Update UI with conversation information
    function updateConversationInfo() {
      const conversationInfo = document.getElementById("conversationInfo");
      if (conversationInfo) {
        const hasRequiredData = v_conversationId && v_toaddress;
        const statusIcon = hasRequiredData ? "‚úÖ" : "‚ö†Ô∏è";
        
        conversationInfo.innerHTML = `
          ${statusIcon} <strong>Active Conversation:</strong><br>
          <div style="margin-left: 10px; font-family: monospace; font-size: 12px;">
            <div><strong>ID:</strong> ${v_conversationId || '‚ùå None'}</div>
            <div><strong>Customer:</strong> ${v_toaddress || '‚ùå None'}</div>
            <div><strong>Workspace ID:</strong> ${v_workspace_id || '‚ùå None'}</div>
            <div><strong>SMS From:</strong> ${v_sms_from_address || '‚ùå None'}</div>
          </div>
          <div style="margin-top: 5px; font-size: 11px; color: ${hasRequiredData ? '#28a745' : '#dc3545'};">
            ${hasRequiredData ? 'Ready to send vCard!' : 'Missing required conversation data'}
          </div>
        `;
      }
    }
          await getUserInfo();
          
          // Subscribe to notifications
          await subscribeToNotifications();
          
          // Enable the send vCard button
          document.getElementById("sendVCardBtn").disabled = false;
          
        } else {
          // Try manual token extraction as fallback
          log("SDK didn't process token automatically, trying manual extraction...");
          await extractTokenManually();
        }
        
      } catch (error) {
        logError("Token processing failed:", error);
        log("Attempting manual token extraction...");
        await extractTokenManually();
      }
    }

    // Extract token manually from URL hash
    async function extractTokenManually() {
      try {
        const token = getParameterByName("access_token");
        const expiresIn = getParameterByName("expires_in");
        
        if (token) {
          log(`Manual token extraction successful. Token: ${token.substring(0, 20)}...`);
          log(`Token expires in: ${expiresIn} seconds`);
          
          // Set the token manually
          genesysClient.setAccessToken(token);
          
          logSuccess("Token set manually");
          document.getElementById("authStatus").innerText = "Authenticated (Manual)";
          
          // Get user information
          await getUserInfo();
          
          // Subscribe to notifications
          await subscribeToNotifications();
          
          // Enable the send vCard button
          document.getElementById("sendVCardBtn").disabled = false;
          
        } else {
          throw new Error("No access token found in URL hash");
        }
        
      } catch (error) {
        logError("Manual token extraction failed:", error);
        document.getElementById("authStatus").innerText = "Authentication failed";
      }
    }

    // Helper function to extract parameters from URL hash
    function getParameterByName(name) {
      name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
      let regex = new RegExp("[\\#&]" + name + "=([^&#]*)");
      let results = regex.exec(location.hash);
      return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
    }

    // Get user information
    async function getUserInfo() {
      try {
        log("Fetching user information...");
        
        me = await usersApi.getUsersMe({ expand: "presence" });
        
        log(`User info retrieved: ${me.name} (ID: ${me.id})`);
        
        // Update UI
        document.getElementById("userName").innerText = me.name;
        document.getElementById("userStatus").innerText = me.presence.presenceDefinition.systemPresence;
        
        logSuccess(`Logged in as: ${me.name}`);
        
      } catch (error) {
        logError("Failed to get user info:", error);
      }
    }

    // Subscribe to notifications
    async function subscribeToNotifications() {
      try {
        log("Setting up notification subscription...");
        
        if (!me) {
          log("No user info available, skipping notifications");
          return;
        }
        
        // Get or create notification channel
        const channels = await notificationsApi.getNotificationsChannels({});
        let channel;
        
        if (!channels || !channels.entities || channels.entities.length === 0) {
          log("Creating new notification channel...");
          channel = await notificationsApi.postNotificationsChannels();
        } else {
          log("Using existing notification channel...");
          channel = channels.entities[channels.entities.length - 1];
        }
        
        // Create websocket connection
        log(`Connecting to websocket: ${channel.connectUri}`);
        webSocket = new WebSocket(channel.connectUri);
        
        webSocket.onopen = function(event) {
          log("Websocket connection opened");
          logSuccess("Notification system connected");
        };
        
        webSocket.onmessage = function(event) {
          const data = JSON.parse(event.data);
          
          // Skip heartbeat messages
          if (data.topicName === 'channel.metadata') {
            return;
          }
          
          log(`üì® Notification received: ${data.topicName}`);
          
          // Process conversation notifications
          if (data.topicName && data.topicName.includes('conversations')) {
            log("üîÑ Processing conversation notification...");
            processConversationNotification(data);
          } else {
            log(`‚ÑπÔ∏è Other notification type: ${data.topicName}`);
          }
        };
        
        webSocket.onerror = function(event) {
          logError("Websocket error:", event);
        };
        
        // Subscribe to user presence and conversation topics
        const topics = [
          `v2.users.${me.id}.presence`,
          `v2.users.${me.id}.conversations`
        ];
        
        log(`Subscribing to topics: ${topics.join(', ')}`);
        
        await notificationsApi.postNotificationsChannelSubscriptions(channel.id, topics);
        log("Subscribed to notification topics successfully");
        
        // Also try to get current active conversations
        log("Checking for existing active conversations...");
        await getActiveConversation();
        
      } catch (error) {
        logError("Failed to setup notifications:", error);
      }
    }

    // Create messaging conversation
    async function createMessagingConversation(toAddress, fromAddress) {
      try {
        log("Creating messaging conversation...");
        
        const body = {
          toAddress: toAddress,
          fromAddress: fromAddress,
          toAddressMessengerType: "sms", // or "open" for other messaging types
          textBody: "Test message from Genesys Cloud vCard sender"
        };
        
        log(`Creating conversation with body:`, body);
        
        const conversation = await conversationApi.postConversationsMessages(body);
        
        log(`Conversation created successfully: ${conversation.id}`);
        logSuccess(`Messaging conversation created: ${conversation.id}`);
        
        return conversation;
        
      } catch (error) {
        logError("Failed to create messaging conversation:", error);
        throw error;
      }
    }

    // Generate vCard and upload to content management
    async function generateVCard() {
      if (!me) {
        logError("No user information available for vCard generation");
        return null;
      }
      
      try {
        log("Starting vCard generation process...");
        
        // Generate vCard content
        const vcard = `BEGIN:VCARD
VERSION:3.0
FN:${me.name}
N:${me.name};;;;
ORG:${me.department || 'Organization'}
TITLE:${me.title || 'Agent'}
EMAIL:${me.email || ''}
TEL:${me.phoneNumber || ''}
END:VCARD`;
        
        log("vCard content generated:");
        log(vcard);
        
        // Check if we have workspace_id from conversation
        if (!v_workspace_id) {
          logError("No workspace ID available. Make sure you're in an active conversation.");
          return null;
        }
        
        log(`Using workspace ID: ${v_workspace_id}`);
        
        // Upload vCard to content management
        const documentResult = await uploadVCardToWorkspace(vcard);
        
        if (documentResult) {
          logSuccess("vCard generated and uploaded successfully!");
          return documentResult;
        } else {
          logError("Failed to upload vCard to workspace");
          return null;
        }
        
      } catch (error) {
        logError("Error in vCard generation process:", error);
        return null;
      }
    }

    // Upload vCard to content management workspace
    async function uploadVCardToWorkspace(vcardContent) {
      try {
        log("Step 1: Preparing vCard file for upload...");
        
        // Create filename with timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `agent-${me.name.replace(/\s+/g, '_')}-${timestamp}.vcf`;
        
        log(`Generated filename: ${filename}`);
        
        // Step 2: Create document in workspace (without body content)
        log("Step 2: Creating document in workspace to get upload URL...");
        
        const createDocumentBody = {
          name: filename,
          workspace: {
            id: v_workspace_id
          },
          filename: filename,
          contentType: 'text/vcard'
          // Note: NO body parameter - content will be uploaded separately
        };
        
        log("üîó API Call: POST /api/v2/contentmanagement/documents");
        log("üì§ Request Body:", JSON.stringify(createDocumentBody, null, 2));
        
        const document = await contentManagementApi.postContentmanagementDocuments(createDocumentBody);
        
        log("‚úÖ Step 3: Document created successfully - got upload URL!");
        log("üì• API Response:", JSON.stringify(document, null, 2));
        log(`Document ID: ${document.id}`);
        log(`Upload Destination URI: ${document.uploadDestinationUri}`);
        log(`Upload Method: ${document.uploadMethod}`);
        
        // Check if we got the upload destination URI
        if (!document.uploadDestinationUri) {
          throw new Error("No uploadDestinationUri received from document creation");
        }
        
        // Step 4: Upload file content to the upload destination URI
        log("üîÑ Step 4: Uploading vCard content to upload destination...");
        
        const uploadResult = await uploadFileToDestination(document.uploadDestinationUri, vcardContent, filename, document.uploadMethod);
        
        if (!uploadResult) {
          throw new Error("File upload to destination failed");
        }
        
        log("‚úÖ Step 5: File content uploaded successfully!");
        
        // Step 6: Monitor upload status using the status URI
        log("üîÑ Step 6: Monitoring upload status...");
        
        const finalDocument = await monitorUploadStatusCorrect(document.uploadStatus.selfUri, document.id);
        
        if (finalDocument) {
          // Step 7: Get final document details including sharing URI
          log("üîÑ Step 7: Retrieving final document details...");
          log(`üîó API Call: GET /api/v2/contentmanagement/documents/${finalDocument.id}`);
          
          const documentDetails = await contentManagementApi.getContentmanagementDocument(finalDocument.id);
          
          log("üì• Final Document Details API Response:", JSON.stringify(documentDetails, null, 2));
          log("‚úÖ Document upload completed successfully!");
          log(`Final Document ID: ${documentDetails.id}`);
          log(`Sharing URI: ${documentDetails.sharingUri || 'Not available'}`);
          
          logSuccess(`vCard uploaded! Document ID: ${documentDetails.id}`);
          
          return {
            documentId: documentDetails.id,
            sharingUri: documentDetails.sharingUri,
            filename: filename
          };
        }
        
        return null;
        
      } catch (error) {
        logError("‚ùå Error uploading vCard to workspace:", error);
        logError("üì• Upload API error response:", error);
        return null;
      }
    }

    // Upload file content to the upload destination URI
    async function uploadFileToDestination(uploadDestinationUri, vcardContent, filename, uploadMethod) {
      try {
        log(`üîó Upload URL: ${uploadDestinationUri}`);
        log(`üì§ Upload Method: ${uploadMethod}`);
        log(`üìÑ File Name: ${filename}`);
        log(`üìù Content Length: ${vcardContent.length} characters`);
        
        // Debug: Check authentication status
        log("üîç Checking authentication status...");
        if (!genesysClient.authData || !genesysClient.authData.accessToken) {
          throw new Error("No authentication token available");
        }
        
        const token = genesysClient.authData.accessToken;
        log(`üîë Token available: ${token.substring(0, 20)}...`);
        log(`üîë Token expires: ${genesysClient.authData.tokenExpiryTimeUtcSeconds || 'Unknown'}`);
        
        // Create FormData for multipart upload
        const formData = new FormData();
        
        // Create blob from vCard content
        const blob = new Blob([vcardContent], { type: 'text/vcard' });
        
        // Add file to form data
        formData.append('file', blob, filename);
        
        log("üì¶ Created multipart form data with file");
        
        // Prepare headers with authentication
        const headers = {
          'Authorization': `Bearer ${token}`
          // Note: Don't set Content-Type header - let browser set it with boundary for multipart
        };
        
        log("üîë Prepared headers with authorization");
        log("üì§ Headers being sent:", JSON.stringify(headers, null, 2));
        
        // Perform the upload
        log("üöÄ Sending authenticated multipart POST request to upload destination...");
        
        const uploadResponse = await fetch(uploadDestinationUri, {
          method: 'POST',
          headers: headers,
          body: formData
        });
        
        log(`üì• Upload Response Status: ${uploadResponse.status} ${uploadResponse.statusText}`);
        log(`üì• Upload Response Headers:`, JSON.stringify([...uploadResponse.headers.entries()], null, 2));
        
        if (!uploadResponse.ok) {
          const errorText = await uploadResponse.text();
          log(`üì• Upload Error Response Body: ${errorText}`);
          
          // Check for specific error types
          if (uploadResponse.status === 401) {
            logError("üîë Authentication failed - token may be expired or invalid");
            logError("üí° Try refreshing your authentication or check token permissions");
            logError("üîç Current token (first 50 chars): " + token.substring(0, 50) + "...");
            
            // Try to test the token with a simple API call
            log("üß™ Testing token with a simple API call...");
            try {
              const testUser = await usersApi.getUsersMe();
              log("‚úÖ Token works for getUsersMe - issue might be with upload endpoint permissions");
            } catch (testError) {
              logError("‚ùå Token doesn't work for basic API calls either:", testError);
            }
            
          } else if (uploadResponse.status === 403) {
            logError("üö´ Access forbidden - check workspace permissions");
          } else if (uploadResponse.status === 413) {
            logError("üìÅ File too large - check file size limits");
          }
          
          throw new Error(`Upload failed with status: ${uploadResponse.status} - ${errorText}`);
        }
        
        // Try to get response body if available
        try {
          const responseText = await uploadResponse.text();
          if (responseText) {
            log("üì• Upload Success Response Body:", responseText);
          } else {
            log("üì• Upload completed - no response body");
          }
        } catch (e) {
          log("üì• Upload completed - couldn't read response body");
        }
        
        logSuccess("‚úÖ File upload to destination completed successfully!");
        return true;
        
      } catch (error) {
        logError("‚ùå Error uploading file to destination:", error);
        
        // Check if it's a CORS error
        if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
          logError("üö´ This appears to be a CORS (Cross-Origin) error.");
          logError("üí° Browser security prevents direct uploads to Genesys Cloud upload URLs.");
        }
        
        // Try alternative approach if upload fails
        logError("üîÑ Upload to destination failed. This might be due to CORS restrictions in browser environments.");
        logError("üí° Alternative: The document was created successfully, you can manually upload the content or use a server-side approach.");
        
        return false;
      }
    }

    // Monitor upload status using the correct status endpoint
    async function monitorUploadStatusCorrect(statusUri, documentId, maxRetries = 10) {
      try {
        log(`üîÑ Monitoring upload status using: ${statusUri}`);
        
        for (let i = 0; i < maxRetries; i++) {
          log(`üìä Status check attempt ${i + 1}/${maxRetries}...`);
          
          // Use the status URI directly or fall back to document endpoint
          let statusResponse;
          try {
            log(`üîó API Call: GET ${statusUri}`);
            
            // Make direct call to status endpoint
            const response = await fetch(statusUri, {
              headers: {
                'Authorization': `Bearer ${genesysClient.authData.accessToken}`,
                'Accept': 'application/json'
              }
            });
            
            if (!response.ok) {
              throw new Error(`Status check failed: ${response.status}`);
            }
            
            statusResponse = await response.json();
            
          } catch (statusError) {
            log(`‚ö†Ô∏è Status endpoint failed, trying document endpoint: ${statusError.message}`);
            log(`üîó API Call: GET /api/v2/contentmanagement/documents/${documentId}`);
            
            statusResponse = await contentManagementApi.getContentmanagementDocument(documentId);
          }
          
          log(`üì• Status Check API Response:`, JSON.stringify(statusResponse, null, 2));
          
          const uploadStatus = statusResponse.uploadStatus?.status || statusResponse.status;
          log(`üìà Current upload status: ${uploadStatus}`);
          
          if (uploadStatus === 'UPLOAD_SUCCESS') {
            logSuccess("‚úÖ Upload completed successfully!");
            return statusResponse;
          } else if (uploadStatus === 'UPLOAD_FAILED') {
            logError("‚ùå Upload failed!");
            log("üì• Failed status details:", JSON.stringify(statusResponse, null, 2));
            return null;
          } else if (uploadStatus === 'UPLOAD_IN_PROGRESS') {
            log("‚è≥ Upload still in progress...");
          } else {
            log(`‚ÑπÔ∏è Upload status: ${uploadStatus || 'Not set'}`);
          }
          
          // Wait 2 seconds before next check
          log("‚è±Ô∏è Waiting 2 seconds before next status check...");
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        logError("‚è∞ Upload status monitoring timed out");
        return null;
        
      } catch (error) {
        logError("‚ùå Error monitoring upload status:", error);
        logError("üì• Monitor status API error response:", error);
        return null;
      }
    }

    // Monitor upload status
    async function monitorUploadStatus(documentId, maxRetries = 10) {
      // This function is now replaced by monitorUploadStatusCorrect
      // Keeping for backward compatibility
      return await monitorUploadStatusCorrect(`/api/v2/contentmanagement/status/${documentId}`, documentId, maxRetries);
    }

    // Main function to send vCard
    async function sendVCard() {
      try {
        log("Send vCard button clicked");
        
        if (!me) {
          logError("User not authenticated");
          return;
        }
        
        // Debug: Show current conversation variables
        log("Current conversation variables:");
        log(`- v_conversationId: ${v_conversationId}`);
        log(`- v_toaddress: ${v_toaddress}`);
        log(`- v_workspace_id: ${v_workspace_id}`);
        log(`- v_sms_from_address: ${v_sms_from_address}`);
        
        // Check if we have conversation data from notifications
        if (!v_conversationId || !v_toaddress) {
          log("No conversation data from notifications. Attempting to fetch active conversations...");
          
          // Fallback: Try to get active conversation data directly
          const activeConversation = await getActiveConversation();
          
          if (!activeConversation) {
            logError("No active conversation detected. Please ensure you're in an active conversation with a customer.");
            logError("Make sure you have an active call or messaging conversation with a customer.");
            return;
          }
        }
        
        log(`Using conversation data:`);
        log(`- Conversation ID: ${v_conversationId}`);
        log(`- Customer address: ${v_toaddress}`);
        log(`- Workspace ID: ${v_workspace_id}`);
        log(`- SMS from address: ${v_sms_from_address}`);
        
        // Generate vCard and upload to workspace
        const vcardResult = await generateVCard();
        if (!vcardResult) {
          logError("Failed to generate and upload vCard");
          return;
        }
        
        logSuccess("vCard process completed successfully!");
        log(`Document ID: ${vcardResult.documentId}`);
        log(`Sharing URI: ${vcardResult.sharingUri}`);
        
        // TODO: In next iteration, we can send the sharing URI via SMS
        log("Next step: Send sharing URI via SMS to customer");
        
      } catch (error) {
        logError("Failed to send vCard:", error);
      }
    }

    // Fallback method to get active conversation data
    async function getActiveConversation() {
      try {
        log("Fetching active conversations for current user...");
        
        // Get active calls
        const callConversations = await conversationApi.getConversationsCalls();
        log(`Found ${callConversations.entities?.length || 0} call conversations`);
        
        // Get active chats/messages
        const chatConversations = await conversationApi.getConversationsChats();
        log(`Found ${chatConversations.entities?.length || 0} chat conversations`);
        
        // Combine all conversations
        const allConversations = [
          ...(callConversations.entities || []),
          ...(chatConversations.entities || [])
        ];
        
        log(`Total conversations found: ${allConversations.length}`);
        
        // Find conversation where current user is connected
        for (const conversation of allConversations) {
          log(`Checking conversation ${conversation.id}...`);
          
          const agentParticipant = conversation.participants.find(p => 
            (p.purpose === 'agent' || p.purpose === 'user') && 
            p.state === 'connected' && 
            p.user && 
            p.user.id === me.id
          );
          
          const customerParticipant = conversation.participants.find(p => p.purpose === 'customer');
          
          if (agentParticipant && customerParticipant) {
            log("Found active conversation with customer!");
            log("Agent participant:", agentParticipant);
            log("Customer participant:", customerParticipant);
            
            // Store the conversation data
            v_conversationId = conversation.id;
            v_toaddress = customerParticipant.address;
            
            // Check for attributes
            if (customerParticipant.attributes) {
              v_workspace_id = customerParticipant.attributes.workspace_id;
              v_sms_from_address = customerParticipant.attributes.sms_from_address;
              log("Customer attributes found:", customerParticipant.attributes);
            } else {
              log("No attributes found in customer participant");
              // For testing, you might want to set a default workspace ID
              // v_workspace_id = "your-default-workspace-id";
            }
            
            // Update UI
            updateConversationInfo();
            
            return conversation;
          }
        }
        
        log("No active conversation with customer found");
        return null;
        
      } catch (error) {
        logError("Error fetching active conversations:", error);
        return null;
      }
    }

    // Refresh user information
    async function refreshUserInfo() {
      log("Refreshing user information...");
      
      // Check if we have a valid token first
      if (!genesysClient.authData || !genesysClient.authData.accessToken) {
        log("No valid token found, checking URL hash...");
        
        if (window.location.hash) {
          await processAuthToken();
        } else {
          logError("No authentication token available. Please authenticate first.");
          document.getElementById("authStatus").innerText = "Not authenticated";
          return;
        }
      }
      
      await getUserInfo();
    }

    // Logging functions
    function log(message, data = null) {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `[${timestamp}] ${message}`;
      
      console.log(logEntry, data || '');
      
      const logContainer = document.getElementById("logContainer");
      const logDiv = document.createElement("div");
      logDiv.className = "log-entry";
      logDiv.textContent = logEntry + (data ? ` ${JSON.stringify(data)}` : '');
      
      logContainer.appendChild(logDiv);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    function logError(message, error = null) {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `[${timestamp}] ERROR: ${message}`;
      
      console.error(logEntry, error || '');
      
      const logContainer = document.getElementById("logContainer");
      const logDiv = document.createElement("div");
      logDiv.className = "log-entry error";
      logDiv.textContent = logEntry + (error ? ` ${error.message || JSON.stringify(error)}` : '');
      
      logContainer.appendChild(logDiv);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    function logSuccess(message) {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `[${timestamp}] SUCCESS: ${message}`;
      
      console.log(logEntry);
      
      const logContainer = document.getElementById("logContainer");
      const logDiv = document.createElement("div");
      logDiv.className = "log-entry success";
      logDiv.textContent = logEntry;
      
      logContainer.appendChild(logDiv);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    // Initialize when page loads
    window.onload = initialize;
  </script>
</body>

</html>
